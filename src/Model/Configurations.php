<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Flownative\Harbor\Api\Model;

class Configurations
{
    /**
     * @var array
     */
    protected $initialized = [];

    public function isInitialized($property): bool
    {
        return array_key_exists($property, $this->initialized);
    }
    /**
     * The auth mode of current system, such as "db_auth", "ldap_auth", "oidc_auth".
     *
     * @var string|null
     */
    protected $authMode;
    /**
     * The flag to indicate whether the current auth mode should consider as a primary one.
     *
     * @var bool|null
     */
    protected $primaryAuthMode;
    /**
     * The Base DN for LDAP binding.
     *
     * @var string|null
     */
    protected $ldapBaseDn;
    /**
     * The filter for LDAP search.
     *
     * @var string|null
     */
    protected $ldapFilter;
    /**
     * The base DN to search LDAP group.
     *
     * @var string|null
     */
    protected $ldapGroupBaseDn;
    /**
     * Specify the ldap group which have the same privilege with Harbor admin.
     *
     * @var string|null
     */
    protected $ldapGroupAdminDn;
    /**
     * The attribute which is used as identity of the LDAP group, default is cn.'.
     *
     * @var string|null
     */
    protected $ldapGroupAttributeName;
    /**
     * The filter to search the ldap group.
     *
     * @var string|null
     */
    protected $ldapGroupSearchFilter;
    /**
     * The scope to search ldap group. ''0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE''.
     *
     * @var int|null
     */
    protected $ldapGroupSearchScope;
    /**
     * The scope to search ldap users,'0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE'.
     *
     * @var int|null
     */
    protected $ldapScope;
    /**
     * The DN of the user to do the search.
     *
     * @var string|null
     */
    protected $ldapSearchDn;
    /**
     * The password of the ldap search dn.
     *
     * @var string|null
     */
    protected $ldapSearchPassword;
    /**
     * Timeout in seconds for connection to LDAP server.
     *
     * @var int|null
     */
    protected $ldapTimeout;
    /**
     * The attribute which is used as identity for the LDAP binding, such as "CN" or "SAMAccountname".
     *
     * @var string|null
     */
    protected $ldapUid;
    /**
     * The URL of LDAP server.
     *
     * @var string|null
     */
    protected $ldapUrl;
    /**
     * Whether verify your OIDC server certificate, disable it if your OIDC server is hosted via self-hosted certificate.
     *
     * @var bool|null
     */
    protected $ldapVerifyCert;
    /**
     * The user attribute to identify the group membership.
     *
     * @var string|null
     */
    protected $ldapGroupMembershipAttribute;
    /**
     * Indicate who can create projects, it could be ''adminonly'' or ''everyone''.
     *
     * @var string|null
     */
    protected $projectCreationRestriction;
    /**
     * The flag to indicate whether Harbor is in readonly mode.
     *
     * @var bool|null
     */
    protected $readOnly;
    /**
     * Whether the Harbor instance supports self-registration.  If it''s set to false, admin need to add user to the instance.
     *
     * @var bool|null
     */
    protected $selfRegistration;
    /**
     * The expiration time of the token for internal Registry, in minutes.
     *
     * @var int|null
     */
    protected $tokenExpiration;
    /**
     * The client id of UAA.
     *
     * @var string|null
     */
    protected $uaaClientId;
    /**
     * The client secret of the UAA.
     *
     * @var string|null
     */
    protected $uaaClientSecret;
    /**
     * The endpoint of the UAA.
     *
     * @var string|null
     */
    protected $uaaEndpoint;
    /**
     * Verify the certificate in UAA server.
     *
     * @var bool|null
     */
    protected $uaaVerifyCert;
    /**
     * The endpoint of the HTTP auth.
     *
     * @var string|null
     */
    protected $httpAuthproxyEndpoint;
    /**
     * The token review endpoint.
     *
     * @var string|null
     */
    protected $httpAuthproxyTokenreviewEndpoint;
    /**
     * The group which has the harbor admin privileges.
     *
     * @var string|null
     */
    protected $httpAuthproxyAdminGroups;
    /**
     * The username which has the harbor admin privileges.
     *
     * @var string|null
     */
    protected $httpAuthproxyAdminUsernames;
    /**
     * Verify the HTTP auth provider's certificate.
     *
     * @var bool|null
     */
    protected $httpAuthproxyVerifyCert;
    /**
     * Search user before onboard.
     *
     * @var bool|null
     */
    protected $httpAuthproxySkipSearch;
    /**
     * The certificate of the HTTP auth provider.
     *
     * @var string|null
     */
    protected $httpAuthproxyServerCertificate;
    /**
     * The OIDC provider name.
     *
     * @var string|null
     */
    protected $oidcName;
    /**
     * The endpoint of the OIDC provider.
     *
     * @var string|null
     */
    protected $oidcEndpoint;
    /**
     * The client ID of the OIDC provider.
     *
     * @var string|null
     */
    protected $oidcClientId;
    /**
     * The OIDC provider secret.
     *
     * @var string|null
     */
    protected $oidcClientSecret;
    /**
     * The attribute claims the group name.
     *
     * @var string|null
     */
    protected $oidcGroupsClaim;
    /**
     * The OIDC group which has the harbor admin privileges.
     *
     * @var string|null
     */
    protected $oidcAdminGroup;
    /**
     * The OIDC group filter which filters out the group name doesn't match the regular expression.
     *
     * @var string|null
     */
    protected $oidcGroupFilter;
    /**
     * The scope of the OIDC provider.
     *
     * @var string|null
     */
    protected $oidcScope;
    /**
     * The attribute claims the username.
     *
     * @var string|null
     */
    protected $oidcUserClaim;
    /**
     * Verify the OIDC provider's certificate'.
     *
     * @var bool|null
     */
    protected $oidcVerifyCert;
    /**
     * Auto onboard the OIDC user.
     *
     * @var bool|null
     */
    protected $oidcAutoOnboard;
    /**
     * Extra parameters to add when redirect request to OIDC provider.
     *
     * @var string|null
     */
    protected $oidcExtraRedirectParms;
    /**
     * The robot account token duration in days.
     *
     * @var int|null
     */
    protected $robotTokenDuration;
    /**
     * The rebot account name prefix.
     *
     * @var string|null
     */
    protected $robotNamePrefix;
    /**
     * Enable notification.
     *
     * @var bool|null
     */
    protected $notificationEnable;
    /**
     * Enable quota per project.
     *
     * @var bool|null
     */
    protected $quotaPerProjectEnable;
    /**
     * The storage quota per project.
     *
     * @var int|null
     */
    protected $storagePerProject;
    /**
     * The audit log forward endpoint.
     *
     * @var string|null
     */
    protected $auditLogForwardEndpoint;
    /**
     * Skip audit log database.
     *
     * @var bool|null
     */
    protected $skipAuditLogDatabase;
    /**
     * The session timeout for harbor, in minutes.
     *
     * @var int|null
     */
    protected $sessionTimeout;
    /**
     * Whether or not to skip update pull time for scanner.
     *
     * @var bool|null
     */
    protected $scannerSkipUpdatePulltime;
    /**
     * The banner message for the UI.It is the stringified result of the banner message object.
     *
     * @var string|null
     */
    protected $bannerMessage;

    /**
     * The auth mode of current system, such as "db_auth", "ldap_auth", "oidc_auth".
     */
    public function getAuthMode(): ?string
    {
        return $this->authMode;
    }

    /**
     * The auth mode of current system, such as "db_auth", "ldap_auth", "oidc_auth".
     */
    public function setAuthMode(?string $authMode): self
    {
        $this->initialized['authMode'] = true;
        $this->authMode = $authMode;

        return $this;
    }

    /**
     * The flag to indicate whether the current auth mode should consider as a primary one.
     */
    public function getPrimaryAuthMode(): ?bool
    {
        return $this->primaryAuthMode;
    }

    /**
     * The flag to indicate whether the current auth mode should consider as a primary one.
     */
    public function setPrimaryAuthMode(?bool $primaryAuthMode): self
    {
        $this->initialized['primaryAuthMode'] = true;
        $this->primaryAuthMode = $primaryAuthMode;

        return $this;
    }

    /**
     * The Base DN for LDAP binding.
     */
    public function getLdapBaseDn(): ?string
    {
        return $this->ldapBaseDn;
    }

    /**
     * The Base DN for LDAP binding.
     */
    public function setLdapBaseDn(?string $ldapBaseDn): self
    {
        $this->initialized['ldapBaseDn'] = true;
        $this->ldapBaseDn = $ldapBaseDn;

        return $this;
    }

    /**
     * The filter for LDAP search.
     */
    public function getLdapFilter(): ?string
    {
        return $this->ldapFilter;
    }

    /**
     * The filter for LDAP search.
     */
    public function setLdapFilter(?string $ldapFilter): self
    {
        $this->initialized['ldapFilter'] = true;
        $this->ldapFilter = $ldapFilter;

        return $this;
    }

    /**
     * The base DN to search LDAP group.
     */
    public function getLdapGroupBaseDn(): ?string
    {
        return $this->ldapGroupBaseDn;
    }

    /**
     * The base DN to search LDAP group.
     */
    public function setLdapGroupBaseDn(?string $ldapGroupBaseDn): self
    {
        $this->initialized['ldapGroupBaseDn'] = true;
        $this->ldapGroupBaseDn = $ldapGroupBaseDn;

        return $this;
    }

    /**
     * Specify the ldap group which have the same privilege with Harbor admin.
     */
    public function getLdapGroupAdminDn(): ?string
    {
        return $this->ldapGroupAdminDn;
    }

    /**
     * Specify the ldap group which have the same privilege with Harbor admin.
     */
    public function setLdapGroupAdminDn(?string $ldapGroupAdminDn): self
    {
        $this->initialized['ldapGroupAdminDn'] = true;
        $this->ldapGroupAdminDn = $ldapGroupAdminDn;

        return $this;
    }

    /**
     * The attribute which is used as identity of the LDAP group, default is cn.'.
     */
    public function getLdapGroupAttributeName(): ?string
    {
        return $this->ldapGroupAttributeName;
    }

    /**
     * The attribute which is used as identity of the LDAP group, default is cn.'.
     */
    public function setLdapGroupAttributeName(?string $ldapGroupAttributeName): self
    {
        $this->initialized['ldapGroupAttributeName'] = true;
        $this->ldapGroupAttributeName = $ldapGroupAttributeName;

        return $this;
    }

    /**
     * The filter to search the ldap group.
     */
    public function getLdapGroupSearchFilter(): ?string
    {
        return $this->ldapGroupSearchFilter;
    }

    /**
     * The filter to search the ldap group.
     */
    public function setLdapGroupSearchFilter(?string $ldapGroupSearchFilter): self
    {
        $this->initialized['ldapGroupSearchFilter'] = true;
        $this->ldapGroupSearchFilter = $ldapGroupSearchFilter;

        return $this;
    }

    /**
     * The scope to search ldap group. ''0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE''.
     */
    public function getLdapGroupSearchScope(): ?int
    {
        return $this->ldapGroupSearchScope;
    }

    /**
     * The scope to search ldap group. ''0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE''.
     */
    public function setLdapGroupSearchScope(?int $ldapGroupSearchScope): self
    {
        $this->initialized['ldapGroupSearchScope'] = true;
        $this->ldapGroupSearchScope = $ldapGroupSearchScope;

        return $this;
    }

    /**
     * The scope to search ldap users,'0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE'.
     */
    public function getLdapScope(): ?int
    {
        return $this->ldapScope;
    }

    /**
     * The scope to search ldap users,'0-LDAP_SCOPE_BASE, 1-LDAP_SCOPE_ONELEVEL, 2-LDAP_SCOPE_SUBTREE'.
     */
    public function setLdapScope(?int $ldapScope): self
    {
        $this->initialized['ldapScope'] = true;
        $this->ldapScope = $ldapScope;

        return $this;
    }

    /**
     * The DN of the user to do the search.
     */
    public function getLdapSearchDn(): ?string
    {
        return $this->ldapSearchDn;
    }

    /**
     * The DN of the user to do the search.
     */
    public function setLdapSearchDn(?string $ldapSearchDn): self
    {
        $this->initialized['ldapSearchDn'] = true;
        $this->ldapSearchDn = $ldapSearchDn;

        return $this;
    }

    /**
     * The password of the ldap search dn.
     */
    public function getLdapSearchPassword(): ?string
    {
        return $this->ldapSearchPassword;
    }

    /**
     * The password of the ldap search dn.
     */
    public function setLdapSearchPassword(?string $ldapSearchPassword): self
    {
        $this->initialized['ldapSearchPassword'] = true;
        $this->ldapSearchPassword = $ldapSearchPassword;

        return $this;
    }

    /**
     * Timeout in seconds for connection to LDAP server.
     */
    public function getLdapTimeout(): ?int
    {
        return $this->ldapTimeout;
    }

    /**
     * Timeout in seconds for connection to LDAP server.
     */
    public function setLdapTimeout(?int $ldapTimeout): self
    {
        $this->initialized['ldapTimeout'] = true;
        $this->ldapTimeout = $ldapTimeout;

        return $this;
    }

    /**
     * The attribute which is used as identity for the LDAP binding, such as "CN" or "SAMAccountname".
     */
    public function getLdapUid(): ?string
    {
        return $this->ldapUid;
    }

    /**
     * The attribute which is used as identity for the LDAP binding, such as "CN" or "SAMAccountname".
     */
    public function setLdapUid(?string $ldapUid): self
    {
        $this->initialized['ldapUid'] = true;
        $this->ldapUid = $ldapUid;

        return $this;
    }

    /**
     * The URL of LDAP server.
     */
    public function getLdapUrl(): ?string
    {
        return $this->ldapUrl;
    }

    /**
     * The URL of LDAP server.
     */
    public function setLdapUrl(?string $ldapUrl): self
    {
        $this->initialized['ldapUrl'] = true;
        $this->ldapUrl = $ldapUrl;

        return $this;
    }

    /**
     * Whether verify your OIDC server certificate, disable it if your OIDC server is hosted via self-hosted certificate.
     */
    public function getLdapVerifyCert(): ?bool
    {
        return $this->ldapVerifyCert;
    }

    /**
     * Whether verify your OIDC server certificate, disable it if your OIDC server is hosted via self-hosted certificate.
     */
    public function setLdapVerifyCert(?bool $ldapVerifyCert): self
    {
        $this->initialized['ldapVerifyCert'] = true;
        $this->ldapVerifyCert = $ldapVerifyCert;

        return $this;
    }

    /**
     * The user attribute to identify the group membership.
     */
    public function getLdapGroupMembershipAttribute(): ?string
    {
        return $this->ldapGroupMembershipAttribute;
    }

    /**
     * The user attribute to identify the group membership.
     */
    public function setLdapGroupMembershipAttribute(?string $ldapGroupMembershipAttribute): self
    {
        $this->initialized['ldapGroupMembershipAttribute'] = true;
        $this->ldapGroupMembershipAttribute = $ldapGroupMembershipAttribute;

        return $this;
    }

    /**
     * Indicate who can create projects, it could be ''adminonly'' or ''everyone''.
     */
    public function getProjectCreationRestriction(): ?string
    {
        return $this->projectCreationRestriction;
    }

    /**
     * Indicate who can create projects, it could be ''adminonly'' or ''everyone''.
     */
    public function setProjectCreationRestriction(?string $projectCreationRestriction): self
    {
        $this->initialized['projectCreationRestriction'] = true;
        $this->projectCreationRestriction = $projectCreationRestriction;

        return $this;
    }

    /**
     * The flag to indicate whether Harbor is in readonly mode.
     */
    public function getReadOnly(): ?bool
    {
        return $this->readOnly;
    }

    /**
     * The flag to indicate whether Harbor is in readonly mode.
     */
    public function setReadOnly(?bool $readOnly): self
    {
        $this->initialized['readOnly'] = true;
        $this->readOnly = $readOnly;

        return $this;
    }

    /**
     * Whether the Harbor instance supports self-registration.  If it''s set to false, admin need to add user to the instance.
     */
    public function getSelfRegistration(): ?bool
    {
        return $this->selfRegistration;
    }

    /**
     * Whether the Harbor instance supports self-registration.  If it''s set to false, admin need to add user to the instance.
     */
    public function setSelfRegistration(?bool $selfRegistration): self
    {
        $this->initialized['selfRegistration'] = true;
        $this->selfRegistration = $selfRegistration;

        return $this;
    }

    /**
     * The expiration time of the token for internal Registry, in minutes.
     */
    public function getTokenExpiration(): ?int
    {
        return $this->tokenExpiration;
    }

    /**
     * The expiration time of the token for internal Registry, in minutes.
     */
    public function setTokenExpiration(?int $tokenExpiration): self
    {
        $this->initialized['tokenExpiration'] = true;
        $this->tokenExpiration = $tokenExpiration;

        return $this;
    }

    /**
     * The client id of UAA.
     */
    public function getUaaClientId(): ?string
    {
        return $this->uaaClientId;
    }

    /**
     * The client id of UAA.
     */
    public function setUaaClientId(?string $uaaClientId): self
    {
        $this->initialized['uaaClientId'] = true;
        $this->uaaClientId = $uaaClientId;

        return $this;
    }

    /**
     * The client secret of the UAA.
     */
    public function getUaaClientSecret(): ?string
    {
        return $this->uaaClientSecret;
    }

    /**
     * The client secret of the UAA.
     */
    public function setUaaClientSecret(?string $uaaClientSecret): self
    {
        $this->initialized['uaaClientSecret'] = true;
        $this->uaaClientSecret = $uaaClientSecret;

        return $this;
    }

    /**
     * The endpoint of the UAA.
     */
    public function getUaaEndpoint(): ?string
    {
        return $this->uaaEndpoint;
    }

    /**
     * The endpoint of the UAA.
     */
    public function setUaaEndpoint(?string $uaaEndpoint): self
    {
        $this->initialized['uaaEndpoint'] = true;
        $this->uaaEndpoint = $uaaEndpoint;

        return $this;
    }

    /**
     * Verify the certificate in UAA server.
     */
    public function getUaaVerifyCert(): ?bool
    {
        return $this->uaaVerifyCert;
    }

    /**
     * Verify the certificate in UAA server.
     */
    public function setUaaVerifyCert(?bool $uaaVerifyCert): self
    {
        $this->initialized['uaaVerifyCert'] = true;
        $this->uaaVerifyCert = $uaaVerifyCert;

        return $this;
    }

    /**
     * The endpoint of the HTTP auth.
     */
    public function getHttpAuthproxyEndpoint(): ?string
    {
        return $this->httpAuthproxyEndpoint;
    }

    /**
     * The endpoint of the HTTP auth.
     */
    public function setHttpAuthproxyEndpoint(?string $httpAuthproxyEndpoint): self
    {
        $this->initialized['httpAuthproxyEndpoint'] = true;
        $this->httpAuthproxyEndpoint = $httpAuthproxyEndpoint;

        return $this;
    }

    /**
     * The token review endpoint.
     */
    public function getHttpAuthproxyTokenreviewEndpoint(): ?string
    {
        return $this->httpAuthproxyTokenreviewEndpoint;
    }

    /**
     * The token review endpoint.
     */
    public function setHttpAuthproxyTokenreviewEndpoint(?string $httpAuthproxyTokenreviewEndpoint): self
    {
        $this->initialized['httpAuthproxyTokenreviewEndpoint'] = true;
        $this->httpAuthproxyTokenreviewEndpoint = $httpAuthproxyTokenreviewEndpoint;

        return $this;
    }

    /**
     * The group which has the harbor admin privileges.
     */
    public function getHttpAuthproxyAdminGroups(): ?string
    {
        return $this->httpAuthproxyAdminGroups;
    }

    /**
     * The group which has the harbor admin privileges.
     */
    public function setHttpAuthproxyAdminGroups(?string $httpAuthproxyAdminGroups): self
    {
        $this->initialized['httpAuthproxyAdminGroups'] = true;
        $this->httpAuthproxyAdminGroups = $httpAuthproxyAdminGroups;

        return $this;
    }

    /**
     * The username which has the harbor admin privileges.
     */
    public function getHttpAuthproxyAdminUsernames(): ?string
    {
        return $this->httpAuthproxyAdminUsernames;
    }

    /**
     * The username which has the harbor admin privileges.
     */
    public function setHttpAuthproxyAdminUsernames(?string $httpAuthproxyAdminUsernames): self
    {
        $this->initialized['httpAuthproxyAdminUsernames'] = true;
        $this->httpAuthproxyAdminUsernames = $httpAuthproxyAdminUsernames;

        return $this;
    }

    /**
     * Verify the HTTP auth provider's certificate.
     */
    public function getHttpAuthproxyVerifyCert(): ?bool
    {
        return $this->httpAuthproxyVerifyCert;
    }

    /**
     * Verify the HTTP auth provider's certificate.
     */
    public function setHttpAuthproxyVerifyCert(?bool $httpAuthproxyVerifyCert): self
    {
        $this->initialized['httpAuthproxyVerifyCert'] = true;
        $this->httpAuthproxyVerifyCert = $httpAuthproxyVerifyCert;

        return $this;
    }

    /**
     * Search user before onboard.
     */
    public function getHttpAuthproxySkipSearch(): ?bool
    {
        return $this->httpAuthproxySkipSearch;
    }

    /**
     * Search user before onboard.
     */
    public function setHttpAuthproxySkipSearch(?bool $httpAuthproxySkipSearch): self
    {
        $this->initialized['httpAuthproxySkipSearch'] = true;
        $this->httpAuthproxySkipSearch = $httpAuthproxySkipSearch;

        return $this;
    }

    /**
     * The certificate of the HTTP auth provider.
     */
    public function getHttpAuthproxyServerCertificate(): ?string
    {
        return $this->httpAuthproxyServerCertificate;
    }

    /**
     * The certificate of the HTTP auth provider.
     */
    public function setHttpAuthproxyServerCertificate(?string $httpAuthproxyServerCertificate): self
    {
        $this->initialized['httpAuthproxyServerCertificate'] = true;
        $this->httpAuthproxyServerCertificate = $httpAuthproxyServerCertificate;

        return $this;
    }

    /**
     * The OIDC provider name.
     */
    public function getOidcName(): ?string
    {
        return $this->oidcName;
    }

    /**
     * The OIDC provider name.
     */
    public function setOidcName(?string $oidcName): self
    {
        $this->initialized['oidcName'] = true;
        $this->oidcName = $oidcName;

        return $this;
    }

    /**
     * The endpoint of the OIDC provider.
     */
    public function getOidcEndpoint(): ?string
    {
        return $this->oidcEndpoint;
    }

    /**
     * The endpoint of the OIDC provider.
     */
    public function setOidcEndpoint(?string $oidcEndpoint): self
    {
        $this->initialized['oidcEndpoint'] = true;
        $this->oidcEndpoint = $oidcEndpoint;

        return $this;
    }

    /**
     * The client ID of the OIDC provider.
     */
    public function getOidcClientId(): ?string
    {
        return $this->oidcClientId;
    }

    /**
     * The client ID of the OIDC provider.
     */
    public function setOidcClientId(?string $oidcClientId): self
    {
        $this->initialized['oidcClientId'] = true;
        $this->oidcClientId = $oidcClientId;

        return $this;
    }

    /**
     * The OIDC provider secret.
     */
    public function getOidcClientSecret(): ?string
    {
        return $this->oidcClientSecret;
    }

    /**
     * The OIDC provider secret.
     */
    public function setOidcClientSecret(?string $oidcClientSecret): self
    {
        $this->initialized['oidcClientSecret'] = true;
        $this->oidcClientSecret = $oidcClientSecret;

        return $this;
    }

    /**
     * The attribute claims the group name.
     */
    public function getOidcGroupsClaim(): ?string
    {
        return $this->oidcGroupsClaim;
    }

    /**
     * The attribute claims the group name.
     */
    public function setOidcGroupsClaim(?string $oidcGroupsClaim): self
    {
        $this->initialized['oidcGroupsClaim'] = true;
        $this->oidcGroupsClaim = $oidcGroupsClaim;

        return $this;
    }

    /**
     * The OIDC group which has the harbor admin privileges.
     */
    public function getOidcAdminGroup(): ?string
    {
        return $this->oidcAdminGroup;
    }

    /**
     * The OIDC group which has the harbor admin privileges.
     */
    public function setOidcAdminGroup(?string $oidcAdminGroup): self
    {
        $this->initialized['oidcAdminGroup'] = true;
        $this->oidcAdminGroup = $oidcAdminGroup;

        return $this;
    }

    /**
     * The OIDC group filter which filters out the group name doesn't match the regular expression.
     */
    public function getOidcGroupFilter(): ?string
    {
        return $this->oidcGroupFilter;
    }

    /**
     * The OIDC group filter which filters out the group name doesn't match the regular expression.
     */
    public function setOidcGroupFilter(?string $oidcGroupFilter): self
    {
        $this->initialized['oidcGroupFilter'] = true;
        $this->oidcGroupFilter = $oidcGroupFilter;

        return $this;
    }

    /**
     * The scope of the OIDC provider.
     */
    public function getOidcScope(): ?string
    {
        return $this->oidcScope;
    }

    /**
     * The scope of the OIDC provider.
     */
    public function setOidcScope(?string $oidcScope): self
    {
        $this->initialized['oidcScope'] = true;
        $this->oidcScope = $oidcScope;

        return $this;
    }

    /**
     * The attribute claims the username.
     */
    public function getOidcUserClaim(): ?string
    {
        return $this->oidcUserClaim;
    }

    /**
     * The attribute claims the username.
     */
    public function setOidcUserClaim(?string $oidcUserClaim): self
    {
        $this->initialized['oidcUserClaim'] = true;
        $this->oidcUserClaim = $oidcUserClaim;

        return $this;
    }

    /**
     * Verify the OIDC provider's certificate'.
     */
    public function getOidcVerifyCert(): ?bool
    {
        return $this->oidcVerifyCert;
    }

    /**
     * Verify the OIDC provider's certificate'.
     */
    public function setOidcVerifyCert(?bool $oidcVerifyCert): self
    {
        $this->initialized['oidcVerifyCert'] = true;
        $this->oidcVerifyCert = $oidcVerifyCert;

        return $this;
    }

    /**
     * Auto onboard the OIDC user.
     */
    public function getOidcAutoOnboard(): ?bool
    {
        return $this->oidcAutoOnboard;
    }

    /**
     * Auto onboard the OIDC user.
     */
    public function setOidcAutoOnboard(?bool $oidcAutoOnboard): self
    {
        $this->initialized['oidcAutoOnboard'] = true;
        $this->oidcAutoOnboard = $oidcAutoOnboard;

        return $this;
    }

    /**
     * Extra parameters to add when redirect request to OIDC provider.
     */
    public function getOidcExtraRedirectParms(): ?string
    {
        return $this->oidcExtraRedirectParms;
    }

    /**
     * Extra parameters to add when redirect request to OIDC provider.
     */
    public function setOidcExtraRedirectParms(?string $oidcExtraRedirectParms): self
    {
        $this->initialized['oidcExtraRedirectParms'] = true;
        $this->oidcExtraRedirectParms = $oidcExtraRedirectParms;

        return $this;
    }

    /**
     * The robot account token duration in days.
     */
    public function getRobotTokenDuration(): ?int
    {
        return $this->robotTokenDuration;
    }

    /**
     * The robot account token duration in days.
     */
    public function setRobotTokenDuration(?int $robotTokenDuration): self
    {
        $this->initialized['robotTokenDuration'] = true;
        $this->robotTokenDuration = $robotTokenDuration;

        return $this;
    }

    /**
     * The rebot account name prefix.
     */
    public function getRobotNamePrefix(): ?string
    {
        return $this->robotNamePrefix;
    }

    /**
     * The rebot account name prefix.
     */
    public function setRobotNamePrefix(?string $robotNamePrefix): self
    {
        $this->initialized['robotNamePrefix'] = true;
        $this->robotNamePrefix = $robotNamePrefix;

        return $this;
    }

    /**
     * Enable notification.
     */
    public function getNotificationEnable(): ?bool
    {
        return $this->notificationEnable;
    }

    /**
     * Enable notification.
     */
    public function setNotificationEnable(?bool $notificationEnable): self
    {
        $this->initialized['notificationEnable'] = true;
        $this->notificationEnable = $notificationEnable;

        return $this;
    }

    /**
     * Enable quota per project.
     */
    public function getQuotaPerProjectEnable(): ?bool
    {
        return $this->quotaPerProjectEnable;
    }

    /**
     * Enable quota per project.
     */
    public function setQuotaPerProjectEnable(?bool $quotaPerProjectEnable): self
    {
        $this->initialized['quotaPerProjectEnable'] = true;
        $this->quotaPerProjectEnable = $quotaPerProjectEnable;

        return $this;
    }

    /**
     * The storage quota per project.
     */
    public function getStoragePerProject(): ?int
    {
        return $this->storagePerProject;
    }

    /**
     * The storage quota per project.
     */
    public function setStoragePerProject(?int $storagePerProject): self
    {
        $this->initialized['storagePerProject'] = true;
        $this->storagePerProject = $storagePerProject;

        return $this;
    }

    /**
     * The audit log forward endpoint.
     */
    public function getAuditLogForwardEndpoint(): ?string
    {
        return $this->auditLogForwardEndpoint;
    }

    /**
     * The audit log forward endpoint.
     */
    public function setAuditLogForwardEndpoint(?string $auditLogForwardEndpoint): self
    {
        $this->initialized['auditLogForwardEndpoint'] = true;
        $this->auditLogForwardEndpoint = $auditLogForwardEndpoint;

        return $this;
    }

    /**
     * Skip audit log database.
     */
    public function getSkipAuditLogDatabase(): ?bool
    {
        return $this->skipAuditLogDatabase;
    }

    /**
     * Skip audit log database.
     */
    public function setSkipAuditLogDatabase(?bool $skipAuditLogDatabase): self
    {
        $this->initialized['skipAuditLogDatabase'] = true;
        $this->skipAuditLogDatabase = $skipAuditLogDatabase;

        return $this;
    }

    /**
     * The session timeout for harbor, in minutes.
     */
    public function getSessionTimeout(): ?int
    {
        return $this->sessionTimeout;
    }

    /**
     * The session timeout for harbor, in minutes.
     */
    public function setSessionTimeout(?int $sessionTimeout): self
    {
        $this->initialized['sessionTimeout'] = true;
        $this->sessionTimeout = $sessionTimeout;

        return $this;
    }

    /**
     * Whether or not to skip update pull time for scanner.
     */
    public function getScannerSkipUpdatePulltime(): ?bool
    {
        return $this->scannerSkipUpdatePulltime;
    }

    /**
     * Whether or not to skip update pull time for scanner.
     */
    public function setScannerSkipUpdatePulltime(?bool $scannerSkipUpdatePulltime): self
    {
        $this->initialized['scannerSkipUpdatePulltime'] = true;
        $this->scannerSkipUpdatePulltime = $scannerSkipUpdatePulltime;

        return $this;
    }

    /**
     * The banner message for the UI.It is the stringified result of the banner message object.
     */
    public function getBannerMessage(): ?string
    {
        return $this->bannerMessage;
    }

    /**
     * The banner message for the UI.It is the stringified result of the banner message object.
     */
    public function setBannerMessage(?string $bannerMessage): self
    {
        $this->initialized['bannerMessage'] = true;
        $this->bannerMessage = $bannerMessage;

        return $this;
    }
}
